[{"diskText":"linterPath = atom.packages.getLoadedPackage(\"linter\").path\nLinter = require \"#{linterPath}/lib/linter\"\n{Range, Point, BufferedProcess} = require 'atom'\n{log, warn} = require \"#{linterPath}/lib/utils\"\n\nclass LinterErb extends Linter\n  # The syntax that the linter handles. May be a string or\n  # list/tuple of strings. Names should be all lowercase.\n  @syntax: ['text.html.erb']\n\n  # A string, list, tuple or callable that returns a string, list or tuple,\n  # containing the command line (with arguments) used to lint.\n  rubyCmd: 'ruby -c -'\n  erbCmd: 'erb -x -T -'\n\n  executablePath: null\n\n  linterName: 'erb'\n\n  # A regex pattern used to extract information from the executable's output.\n  regex: '.+:(?<line>\\\\d+):(?<error>)(?<message>.+)'\n\n  constructor: (editor) ->\n    super(editor)\n\n    atom.config.observe 'linter-erb.erbExecutablePath', =>\n      @executablePath = atom.config.get 'linter-erb.erbExecutablePath'\n\n  destroy: ->\n    atom.config.unobserve 'linter-erb.erbExecutablePath'\n\n  lintFile: (filePath, callback) ->\n    # build the command with arguments to lint the file\n    @cmd = @rubyCmd\n    {command: rubyCommand, args: rubyArgs} = @getCmdAndArgs(null)\n    @cmd = @erbCmd\n    {command: erbCommand, args: erbArgs} = @getCmdAndArgs(filePath)\n\n    # options for BufferedProcess, same syntax with child_process.spawn\n    rubyOptions = {stdio: ['pipe', null, null]}\n    erbOptions = {cwd: @cwd}\n\n    data = []\n\n    rubyStderr = (output) ->\n      warn 'stderr', output\n      data += output\n\n    rubyExit = =>\n      @processMessage data, callback\n\n    erbStdout = (output) ->\n      log 'stdout', output\n      rubyProcess.process.stdin.write(output)\n\n    erbExit = =>\n      rubyProcess.process.stdin.end()\n\n    rubyProcess = new BufferedProcess({command: rubyCommand, args: rubyArgs\n                                     , options: rubyOptions, stderr: rubyStderr\n                                     , exit: rubyExit})\n\n    erbProcess = new BufferedProcess({command: erbCommand, args: erbArgs\n                                    , options: erbOptions, stdout: erbStdout\n                                    , exit: erbExit})\n\n    # Don't block UI more than 5seconds, it's really annoying on big files\n    setTimeout ->\n      rubyProcess.kill()\n      erbProcess.kill()\n    , 5000\n\n  createMessage: (match) ->\n    # Easy fix when editor has no newline at end of file\n    if match.line > @editor.getLineCount()\n      match.line = @editor.getLineCount()\n    super(match)\n\nmodule.exports = LinterErb\n","text":"linterPath = atom.packages.getLoadedPackage(\"linter\").path\nLinter = require \"#{linterPath}/lib/linter\"\n{Range, Point, BufferedProcess} = require 'atom'\n{log, warn} = require \"#{linterPath}/lib/utils\"\n\nclass LinterErb extends Linter\n  # The syntax that the linter handles. May be a string or\n  # list/tuple of strings. Names should be all lowercase.\n  @syntax: ['text.html.erb']\n\n  # A string, list, tuple or callable that returns a string, list or tuple,\n  # containing the command line (with arguments) used to lint.\n  rubyCmd: 'ruby -c -'\n  erbCmd: 'erb -x -T -'\n\n  executablePath: null\n\n  linterName: 'erb'\n\n  # A regex pattern used to extract information from the executable's output.\n  regex: '.+:(?<line>\\\\d+):(?<error>)(?<message>.+)'\n\n  constructor: (editor) ->\n    super(editor)\n\n    atom.config.observe 'linter-erb.erbExecutablePath', =>\n      @executablePath = atom.config.get 'linter-erb.erbExecutablePath'\n\n  destroy: ->\n    atom.config.unobserve 'linter-erb.erbExecutablePath'\n\n  lintFile: (filePath, callback) ->\n    # build the command with arguments to lint the file\n    @cmd = @rubyCmd\n    {command: rubyCommand, args: rubyArgs} = @getCmdAndArgs(null)\n    @cmd = @erbCmd\n    {command: erbCommand, args: erbArgs} = @getCmdAndArgs(filePath)\n\n    # options for BufferedProcess, same syntax with child_process.spawn\n    rubyOptions = {stdio: ['pipe', null, null]}\n    erbOptions = {cwd: @cwd}\n\n    data = []\n\n    rubyStderr = (output) ->\n      warn 'stderr', output\n      data += output\n\n    rubyExit = =>\n      @processMessage data, callback\n\n    erbStdout = (output) ->\n      log 'stdout', output\n      rubyProcess.process.stdin.write(output)\n\n    erbExit = =>\n      rubyProcess.process.stdin.end()\n\n    rubyProcess = new BufferedProcess({command: rubyCommand, args: rubyArgs\n                                     , options: rubyOptions, stderr: rubyStderr\n                                     , exit: rubyExit})\n\n    erbProcess = new BufferedProcess({command: erbCommand, args: erbArgs\n                                    , options: erbOptions, stdout: erbStdout\n                                    , exit: erbExit})\n\n    # Don't block UI more than 5seconds, it's really annoying on big files\n    setTimeout ->\n      rubyProcess.kill()\n      erbProcess.kill()\n    , 5000\n\n  createMessage: (match) ->\n    # Easy fix when editor has no newline at end of file\n    if match.line > @editor.getLineCount()\n      match.line = @editor.getLineCount()\n    super(match)\n\nmodule.exports = LinterErb\n","active":false,"path":"/Users/camdennarzt/Developer/Bash/dot-files/.atom/packages/linter-erb/lib/linter-erb.coffee","scroll":2,"cursor":{"row":0,"column":0}}]