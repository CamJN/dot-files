[{"text":"require 'date'\nrequire 'json'\nrequire 'net/http'\nrequire 'uri'\nrequire 'active_support/all'\nrequire 'open-uri'\nrequire 'open_uri_redirections'\nrequire 'nokogiri'\n\nclass Updater\n\n  @@names = {\n    linux: [/.*\\.linux-i686\\.tar\\.bz2\\z/],\n    linux64: [/.*\\.linux-x86_64\\.tar\\.bz2\\z/],\n    win: [/.*\\.win32\\.zip\\z/, /.*\\.win32\\.installer\\.exe\\z/],\n    win64: [/.*\\.win64-x86_64\\.installer\\.exe/,/.*\\.win64-x86_64\\.zip/,/.*\\.win64\\.zip/,/.*\\.win64\\.installer\\.exe/],\n    mac: [/.*\\.mac64\\.dmg/, /.*\\.mac\\.dmg/]\n  }\n\n  @@dates = [\n    Date.new(2013,12,29),\n    Date.new(2014,1,1)\n  ]\n\n  def self.dates=(dates)\n    @@dates = dates\n  end\n\n  def run\n    @@dates = (4.days.ago.to_date .. Date.today).to_a if @@dates.nil?\n\n    @@dates.each_with_index do |date,i|\n      date_url = URI(\"https://ftp.mozilla.org/pub/mozilla.org/firefox/nightly/#{date.strftime('%Y')}/#{date.strftime('%m')}/\")\n      links = Nokogiri::HTML(open(date_url.to_s)).css('a').select{|e|\n        e.text.strip =~ Regexp.new(date.strftime(\"\\\\A%Y-%m-%d-.+-mozilla-central/\\\\z\"))\n      }.map do |l|\n        fetch_current_day(date_url, l, date)\n      end\n      record_day(date,links)\n      puts \"#{100*(i+1)/@@dates.length}% done\\n\"\n    end\n  end\n\n  def get_size(uri)\n    http = Net::HTTP.new(uri.host, uri.port)\n    http.use_ssl = true if uri.scheme == 'https'\n    file_size = http.request_head(uri.path)['content-length']\n\n    file_size.to_i\n  end\n\n  def fetch_current_day(date_url, l, date)\n    day_url = URI.join(date_url.to_s,l['href'])\n    reduced = Nokogiri::HTML(open(day_url)).css('a').reduce({}) do |sizes,e|\n      @@names.each do |os, suffixes|\n        suffixes.each do |sfx|\n          sizes[os] = get_size(URI.join(day_url, e['href'])) if e.text.strip =~ sfx\n        end\n      end\n      sizes\n    end\n  end\n\n  def record_day(date,data)\n    rec = Record.first(day: date)\n    rec = Record.new(day: date) unless rec\n    sizes = {}.merge(data.pop)\n    data.each { |d| sizes.merge!(d) }\n    rec.data = sizes.to_json\n    rec.save\n  end\nend\n\ndef run_updater(backfilling=false)\n  puts \"[Updater] starting...\"\n\n  begin\n    Updater.dates = nil unless backfilling\n    updater = Updater.new.run\n    update = Update.new(finished: DateTime.now)\n    update.save rescue false\n    Arewesmallyet.cache.clear\n  rescue\n    puts \"[Updater] ERROR: #{$@}: #{$!}\"\n  end\n\n  puts \"[Updater] finished!\"\nend\n\ntask :update_once => [:environment] do\n  run_updater\n  check_versions\nend\n\ntask :backfill => [:environment] do\n  run_updater true\nend\n\ndef check_versions\n  page_url = 'https://www.mozilla.org/en-US/firefox/releases/'\n  contents = Nokogiri::HTML(open(page_url)).css('#main-content > ol > li > strong > a').map{|e| {text:e.text,href:e['href']} }.map do |v|\n    {date_str: Nokogiri::HTML(open(URI.join(page_url,v[:href]).to_s,allow_redirections: :all))\n      .css('header.notes-head > h2, #main-feature > h2 > small, #main-feature > p > em').text\n      .split(/ (released|users) (on )?/).last,\n     version: v[:text]}\n  end.select{|e| !e[:date_str].nil? }.map do |e|\n    [Date.parse(e[:date_str]).to_s, e[:version].sub(/\\.0$/,'')]\n  end.reverse.to_s.prepend('var releaseDates = ').concat(';')\n  File.open('app/assets/javascripts/releases.js', 'w') { |file| file.write(contents) }\nend\n","diskText":"","path":"/Users/camdennarzt/Developer/Ruby/arewesmallyet/tasks/update.rake"}]