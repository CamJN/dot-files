[{"diskText":"# -*- coding: utf-8 -*-\n# Configures your navigation\nSimpleNavigation::Configuration.run do |navigation|\n\n  navigation.renderer = SimpleNavigation::Renderer::Bootstrap\n\n  navigation.items do |secondary|\n    secondary.item :user, user_signed_in?? current_user.login : 'Guest', '#' do |sub_nav|\n      if user_signed_in?\n        sub_nav.item :edit_profile, 'Edit profile', edit_user_registration_path\n        sub_nav.item :logout, 'Logout', destroy_user_session_path, method: :delete\n      else\n        sub_nav.item :sign_up, 'Sign up', new_user_registration_path\n        sub_nav.item :login, 'Login', new_user_session_path\n      end\n    end\n    secondary.dom_class = \"nav navbar-nav navbar-right\"\n    secondary.auto_highlight = false\n  end\nend\n","text":"# -*- coding: utf-8 -*-\n# Configures your navigation\nSimpleNavigation::Configuration.run do |navigation|\n\n  navigation.renderer = SimpleNavigation::Renderer::Bootstrap\n\n  navigation.items do |secondary|\n    secondary.item :user, user_signed_in?? current_user.login : 'Guest', '#' do |sub_nav|\n      if user_signed_in?\n        sub_nav.item :edit_profile, 'Edit profile', edit_user_registration_path\n        sub_nav.item :logout, 'Logout', destroy_user_session_path, method: :delete\n      else\n        sub_nav.item :sign_up, 'Sign up', new_user_registration_path\n        sub_nav.item :login, 'Login', new_user_session_path\n      end\n    end\n    secondary.dom_class = \"nav navbar-nav navbar-right\"\n    secondary.auto_highlight = false\n  end\nend\n","active":false,"path":"/Users/camdennarzt/Developer/Ruby/blog/config/navigations/user_navigation.rb","scroll":null,"cursor":{"row":13,"column":38}},{"diskText":"class User < ActiveRecord::Base\n  # Include default devise modules. Others available are:\n  # :omniauthable, :rememberable\n  # not :reconfirmable despite evidence to the contrary in the migration\n  devise :database_authenticatable, :registerable,\n         :confirmable, :lockable, :timeoutable,\n         :recoverable, :trackable, :validatable\n  belongs_to :role\n  before_create :set_default_role\n  has_many :comments, dependent: :destroy\n\n  attr_writer :login\n\n  def login\n    @login || self.username || self.email\n  end\n\n  validates :email, presence: true, confirmation: true, uniqueness: { case_sensitive: false  },\n                    length: {minimum: 3, maximum: 255}, format: { with: /\\A[^@]+@[^@]+\\z/ }\n  validates :username, presence: true, uniqueness: true, length: {minimum: 1, maximum: 255}\n  validates_format_of :password, allow_nil: true, with: /\\A(?=.*[[:lower:]])(?=.*[[:upper:]])(?=.*[[:digit:]])(?=.*[^[:alnum:][:space:]]).*\\z/, message: 'must contain an uppercase, lowercase, digit, and symbol'\n\n  def self.find_first_by_auth_conditions(warden_conditions)\n      conditions = warden_conditions.dup\n      if login = conditions.delete(:login)\n        where(conditions).where([\"username = :value OR lower(email) = :value\", { value: login.downcase }]).first\n      else\n        where(conditions).first\n      end\n  end\n\n  private\n  def set_default_role\n    self.role ||= Role.find_by_name('registered')\n  end\nend\n","text":"class User < ActiveRecord::Base\n  # Include default devise modules. Others available are:\n  # :omniauthable, :rememberable\n  # not :reconfirmable despite evidence to the contrary in the migration\n  devise :database_authenticatable, :registerable,\n         :confirmable, :lockable, :timeoutable,\n         :recoverable, :trackable, :validatable\n  belongs_to :role\n  before_create :set_default_role\n  has_many :comments, dependent: :destroy\n\n  attr_writer :login\n\n  def login\n    @login || self.username || self.email\n  end\n\n  validates :email, presence: true, confirmation: true, uniqueness: { case_sensitive: false  },\n                    length: {minimum: 3, maximum: 255}, format: { with: /\\A[^@]+@[^@]+\\z/ }\n  validates :username, presence: true, uniqueness: true, length: {minimum: 1, maximum: 255}\n  validates_format_of :password, allow_nil: true, with: /\\A(?=.*[[:lower:]])(?=.*[[:upper:]])(?=.*[[:digit:]])(?=.*[^[:alnum:][:space:]]).*\\z/, message: 'must contain an uppercase, lowercase, digit, and symbol'\n\n  def self.find_first_by_auth_conditions(warden_conditions)\n      conditions = warden_conditions.dup\n      if login = conditions.delete(:login)\n        where(conditions).where([\"username = :value OR lower(email) = :value\", { value: login.downcase }]).first\n      else\n        where(conditions).first\n      end\n  end\n\n  private\n  def set_default_role\n    self.role ||= Role.find_by_name('registered')\n  end\nend\n","active":false,"path":"/Users/camdennarzt/Developer/Ruby/blog/app/models/user.rb","scroll":2,"cursor":{"row":25,"column":46}},{"diskText":"# Use this hook to configure devise mailer, warden hooks and so forth.\n# Many of these configuration options can be set straight in your model.\nDevise.setup do |config|\n  # The secret key used by Devise. Devise uses this key to generate\n  # random tokens. Changing this key will render invalid all existing\n  # confirmation, reset password and unlock tokens in the database.\n  config.secret_key = Rails.application.secrets.secret_key_base\n\n\n  # ==> Mailer Configuration\n  # Configure the e-mail address which will be shown in Devise::Mailer,\n  # note that it will be overwritten if you use your own mailer class\n  # with default \"from\" parameter.\n  config.mailer_sender = 'system@blog.dev'\n\n  # Configure the class responsible to send e-mails.\n  # config.mailer = 'Devise::Mailer'\n\n  # ==> ORM configuration\n  # Load and configure the ORM. Supports :active_record (default) and\n  # :mongoid (bson_ext recommended) by default. Other ORMs may be\n  # available as additional gems.\n  require 'devise/orm/active_record'\n\n  # ==> Configuration for any authentication mechanism\n  # Configure which keys are used when authenticating a user. The default is\n  # just :email. You can configure it to use [:username, :subdomain], so for\n  # authenticating a user, both parameters are required. Remember that those\n  # parameters are used only when authenticating and not when retrieving from\n  # session. If you need permissions, you should implement that in a before filter.\n  # You can also supply a hash where the value is a boolean determining whether\n  # or not authentication should be aborted when the value is not present.\n  config.authentication_keys = [ :login ]\n\n  # Configure parameters from the request object used for authentication. Each entry\n  # given should be a request method and it will automatically be passed to the\n  # find_for_authentication method and considered in your model lookup. For instance,\n  # if you set :request_keys to [:subdomain], :subdomain will be used on authentication.\n  # The same considerations mentioned for authentication_keys also apply to request_keys.\n  # config.request_keys = [ :email]\n\n  # Configure which authentication keys should be case-insensitive.\n  # These keys will be downcased upon creating or modifying a user and when used\n  # to authenticate or find a user. Default is :email.\n  config.case_insensitive_keys = [ :email ]\n\n  # Configure which authentication keys should have whitespace stripped.\n  # These keys will have whitespace before and after removed upon creating or\n  # modifying a user and when used to authenticate or find a user. Default is :email.\n  config.strip_whitespace_keys = [ :email ]\n\n  # Tell if authentication through request.params is enabled. True by default.\n  # It can be set to an array that will enable params authentication only for the\n  # given strategies, for example, `config.params_authenticatable = [:database]` will\n  # enable it only for database (email + password) authentication.\n  # config.params_authenticatable = true\n\n  # Tell if authentication through HTTP Auth is enabled. False by default.\n  # It can be set to an array that will enable http authentication only for the\n  # given strategies, for example, `config.http_authenticatable = [:database]` will\n  # enable it only for database authentication. The supported strategies are:\n  # :database      = Support basic authentication with authentication key + password\n  # config.http_authenticatable = false\n\n  # If http headers should be returned for AJAX requests. True by default.\n  # config.http_authenticatable_on_xhr = true\n\n  # The realm used in Http Basic Authentication. 'Application' by default.\n  # config.http_authentication_realm = 'Application'\n\n  # It will change confirmation, password recovery and other workflows\n  # to behave the same regardless if the e-mail provided was right or wrong.\n  # Does not affect registerable.\n  # config.paranoid = true\n\n  # By default Devise will store the user in session. You can skip storage for\n  # particular strategies by setting this option.\n  # Notice that if you are skipping storage for all authentication paths, you\n  # may want to disable generating routes to Devise's sessions controller by\n  # passing skip: :sessions to `devise_for` in your config/routes.rb\n  config.skip_session_storage = [:http_auth]\n\n  # By default, Devise cleans up the CSRF token on authentication to\n  # avoid CSRF token fixation attacks. This means that, when using AJAX\n  # requests for sign in and sign up, you need to get a new CSRF token\n  # from the server. You can disable this option at your own risk.\n  # config.clean_up_csrf_token_on_authentication = true\n\n  # ==> Configuration for :database_authenticatable\n  # For bcrypt, this is the cost for hashing the password and defaults to 10. If\n  # using other encryptors, it sets how many times you want the password re-encrypted.\n  #\n  # Limiting the stretches to just one in testing will increase the performance of\n  # your test suite dramatically. However, it is STRONGLY RECOMMENDED to not use\n  # a value less than 10 in other environments. Note that, for bcrypt (the default\n  # encryptor), the cost increases exponentially with the number of stretches (e.g.\n  # a value of 20 is already extremely slow: approx. 60 seconds for 1 calculation).\n  config.stretches = Rails.env.test? ? 1 : 10\n\n  # Setup a pepper to generate the encrypted password.\n  config.pepper = Rails.application.secrets.secret_key_pepper\n\n  # ==> Configuration for :confirmable\n  # A period that the user is allowed to access the website even without\n  # confirming their account. For instance, if set to 2.days, the user will be\n  # able to access the website for two days without confirming their account,\n  # access will be blocked just in the third day. Default is 0.days, meaning\n  # the user cannot access the website without confirming their account.\n  config.allow_unconfirmed_access_for = 1.days\n\n  # A period that the user is allowed to confirm their account before their\n  # token becomes invalid. For example, if set to 3.days, the user can confirm\n  # their account within 3 days after the mail was sent, but on the fourth day\n  # their account can't be confirmed with the token any more.\n  # Default is nil, meaning there is no restriction on how long a user can take\n  # before confirming their account.\n  config.confirm_within = 1.days\n\n  # If true, requires any email changes to be confirmed (exactly the same way as\n  # initial account confirmation) to be applied. Requires additional unconfirmed_email\n  # db field (see migrations). Until confirmed, new email is stored in\n  # unconfirmed_email column, and copied to email column on successful confirmation.\n  config.reconfirmable = true\n\n  # Defines which key will be used when confirming an account\n  config.confirmation_keys = [ :login ]\n\n  # ==> Configuration for :rememberable\n  # The time the user will be remembered without asking for credentials again.\n  # config.remember_for = 10.minutes\n\n  # Invalidates all the remember me tokens when the user signs out.\n  config.expire_all_remember_me_on_sign_out = true\n\n  # If true, extends the user's remember period when remembered via cookie.\n  # config.extend_remember_period = false\n\n  # Options to be passed to the created cookie. For instance, you can set\n  # secure: true in order to force SSL only cookies.\n  config.rememberable_options = {secure: true}\n\n  # ==> Configuration for :validatable\n  # Range for password length.\n  config.password_length = 8..128\n\n  # Email regex used to validate email formats. It simply asserts that\n  # one (and only one) @ exists in the given string. This is mainly\n  # to give user feedback and not to assert the e-mail validity.\n  # I added the requirement that the domain contain a dot and not end with a dot\n  config.email_regexp = /\\A[^@]+@[^@]+\\z/\n\n  # ==> Configuration for :timeoutable\n  # The time you want to timeout the user session without activity. After this\n  # time the user will be asked for credentials again. Default is 30 minutes.\n  config.timeout_in = 10.minutes\n\n  # If true, expires auth token on session timeout.\n  config.expire_auth_token_on_timeout = true\n\n  # ==> Configuration for :lockable\n  # Defines which strategy will be used to lock an account.\n  # :failed_attempts = Locks an account after a number of failed attempts to sign in.\n  # :none            = No lock strategy. You should handle locking by yourself.\n  config.lock_strategy = :failed_attempts\n\n  # Defines which key will be used when locking and unlocking an account\n  config.unlock_keys = [ :email ]\n\n  # Defines which strategy will be used to unlock an account.\n  # :email = Sends an unlock link to the user email\n  # :time  = Re-enables login after a certain amount of time (see :unlock_in below)\n  # :both  = Enables both strategies\n  # :none  = No unlock strategy. You should handle unlocking by yourself.\n  config.unlock_strategy = :email\n\n  # Number of authentication tries before locking an account if lock_strategy\n  # is failed attempts.\n  config.maximum_attempts = 3\n\n  # Time interval to unlock the account if :time is enabled as unlock_strategy.\n  # config.unlock_in = 1.hour\n\n  # Warn on the last attempt before the account is locked.\n  config.last_attempt_warning = true\n\n  # ==> Configuration for :recoverable\n  #\n  # Defines which key will be used when recovering the password for an account\n  config.reset_password_keys = [ :login ]\n\n  # Time interval you can reset your password with a reset password key.\n  # Don't put a too small interval or your users won't have the time to\n  # change their passwords.\n  config.reset_password_within = 1.hours\n\n  # ==> Configuration for :encryptable\n  # Allow you to use another encryption algorithm besides bcrypt (default). You can use\n  # :sha1, :sha512 or encryptors from others authentication tools as :clearance_sha1,\n  # :authlogic_sha512 (then you should set stretches above to 20 for default behavior)\n  # and :restful_authentication_sha1 (then you should set stretches to 10, and copy\n  # REST_AUTH_SITE_KEY to pepper).\n  #\n  # Require the `devise-encryptable` gem when using anything other than bcrypt\n  # config.encryptor = :sha512\n\n  # ==> Scopes configuration\n  # Turn scoped views on. Before rendering \"sessions/new\", it will first check for\n  # \"users/sessions/new\". It's turned off by default because it's slower if you\n  # are using only default views.\n  # config.scoped_views = false\n\n  # Configure the default scope given to Warden. By default it's the first\n  # devise role declared in your routes (usually :user).\n  # config.default_scope = :user\n\n  # Set this configuration to false if you want /users/sign_out to sign out\n  # only the current scope. By default, Devise signs out all scopes.\n  # config.sign_out_all_scopes = true\n\n  # ==> Navigation configuration\n  # Lists the formats that should be treated as navigational. Formats like\n  # :html, should redirect to the sign in page when the user does not have\n  # access, but formats like :xml or :json, should return 401.\n  #\n  # If you have any extra navigational formats, like :iphone or :mobile, you\n  # should add them to the navigational formats lists.\n  #\n  # The \"*/*\" below is required to match Internet Explorer requests.\n  config.navigational_formats = ['*/*', :html]\n\n  # The default HTTP method used to sign out a resource. Default is :delete.\n  config.sign_out_via = :delete\n\n  # ==> OmniAuth\n  # Add a new OmniAuth provider. Check the wiki for more information on setting\n  # up on your models and hooks.\n  # config.omniauth :github, 'APP_ID', 'APP_SECRET', scope: 'user,public_repo'\n\n  # ==> Warden configuration\n  # If you want to use other strategies, that are not supported by Devise, or\n  # change the failure app, you can configure them inside the config.warden block.\n  #\n  # config.warden do |manager|\n  #   manager.intercept_401 = false\n  #   manager.default_strategies(scope: :user).unshift :some_external_strategy\n  # end\n\n  # ==> Mountable engine configurations\n  # When using Devise inside an engine, let's call it `MyEngine`, and this engine\n  # is mountable, there are some extra configurations to be taken into account.\n  # The following options are available, assuming the engine is mounted as:\n  #\n  #     mount MyEngine, at: '/my_engine'\n  #\n  # The router that invoked `devise_for`, in the example above, would be:\n  # config.router_name = :my_engine\n  #\n  # When using omniauth, Devise cannot automatically set Omniauth path,\n  # so you need to do it manually. For the users scope, it would be:\n  # config.omniauth_path_prefix = '/my_engine/users/auth'\nend\n","text":"# Use this hook to configure devise mailer, warden hooks and so forth.\n# Many of these configuration options can be set straight in your model.\nDevise.setup do |config|\n  # The secret key used by Devise. Devise uses this key to generate\n  # random tokens. Changing this key will render invalid all existing\n  # confirmation, reset password and unlock tokens in the database.\n  config.secret_key = Rails.application.secrets.secret_key_base\n\n\n  # ==> Mailer Configuration\n  # Configure the e-mail address which will be shown in Devise::Mailer,\n  # note that it will be overwritten if you use your own mailer class\n  # with default \"from\" parameter.\n  config.mailer_sender = 'system@blog.dev'\n\n  # Configure the class responsible to send e-mails.\n  # config.mailer = 'Devise::Mailer'\n\n  # ==> ORM configuration\n  # Load and configure the ORM. Supports :active_record (default) and\n  # :mongoid (bson_ext recommended) by default. Other ORMs may be\n  # available as additional gems.\n  require 'devise/orm/active_record'\n\n  # ==> Configuration for any authentication mechanism\n  # Configure which keys are used when authenticating a user. The default is\n  # just :email. You can configure it to use [:username, :subdomain], so for\n  # authenticating a user, both parameters are required. Remember that those\n  # parameters are used only when authenticating and not when retrieving from\n  # session. If you need permissions, you should implement that in a before filter.\n  # You can also supply a hash where the value is a boolean determining whether\n  # or not authentication should be aborted when the value is not present.\n  config.authentication_keys = [ :login ]\n\n  # Configure parameters from the request object used for authentication. Each entry\n  # given should be a request method and it will automatically be passed to the\n  # find_for_authentication method and considered in your model lookup. For instance,\n  # if you set :request_keys to [:subdomain], :subdomain will be used on authentication.\n  # The same considerations mentioned for authentication_keys also apply to request_keys.\n  # config.request_keys = [ :email]\n\n  # Configure which authentication keys should be case-insensitive.\n  # These keys will be downcased upon creating or modifying a user and when used\n  # to authenticate or find a user. Default is :email.\n  config.case_insensitive_keys = [ :email ]\n\n  # Configure which authentication keys should have whitespace stripped.\n  # These keys will have whitespace before and after removed upon creating or\n  # modifying a user and when used to authenticate or find a user. Default is :email.\n  config.strip_whitespace_keys = [ :email ]\n\n  # Tell if authentication through request.params is enabled. True by default.\n  # It can be set to an array that will enable params authentication only for the\n  # given strategies, for example, `config.params_authenticatable = [:database]` will\n  # enable it only for database (email + password) authentication.\n  # config.params_authenticatable = true\n\n  # Tell if authentication through HTTP Auth is enabled. False by default.\n  # It can be set to an array that will enable http authentication only for the\n  # given strategies, for example, `config.http_authenticatable = [:database]` will\n  # enable it only for database authentication. The supported strategies are:\n  # :database      = Support basic authentication with authentication key + password\n  # config.http_authenticatable = false\n\n  # If http headers should be returned for AJAX requests. True by default.\n  # config.http_authenticatable_on_xhr = true\n\n  # The realm used in Http Basic Authentication. 'Application' by default.\n  # config.http_authentication_realm = 'Application'\n\n  # It will change confirmation, password recovery and other workflows\n  # to behave the same regardless if the e-mail provided was right or wrong.\n  # Does not affect registerable.\n  # config.paranoid = true\n\n  # By default Devise will store the user in session. You can skip storage for\n  # particular strategies by setting this option.\n  # Notice that if you are skipping storage for all authentication paths, you\n  # may want to disable generating routes to Devise's sessions controller by\n  # passing skip: :sessions to `devise_for` in your config/routes.rb\n  config.skip_session_storage = [:http_auth]\n\n  # By default, Devise cleans up the CSRF token on authentication to\n  # avoid CSRF token fixation attacks. This means that, when using AJAX\n  # requests for sign in and sign up, you need to get a new CSRF token\n  # from the server. You can disable this option at your own risk.\n  # config.clean_up_csrf_token_on_authentication = true\n\n  # ==> Configuration for :database_authenticatable\n  # For bcrypt, this is the cost for hashing the password and defaults to 10. If\n  # using other encryptors, it sets how many times you want the password re-encrypted.\n  #\n  # Limiting the stretches to just one in testing will increase the performance of\n  # your test suite dramatically. However, it is STRONGLY RECOMMENDED to not use\n  # a value less than 10 in other environments. Note that, for bcrypt (the default\n  # encryptor), the cost increases exponentially with the number of stretches (e.g.\n  # a value of 20 is already extremely slow: approx. 60 seconds for 1 calculation).\n  config.stretches = Rails.env.test? ? 1 : 10\n\n  # Setup a pepper to generate the encrypted password.\n  config.pepper = Rails.application.secrets.secret_key_pepper\n\n  # ==> Configuration for :confirmable\n  # A period that the user is allowed to access the website even without\n  # confirming their account. For instance, if set to 2.days, the user will be\n  # able to access the website for two days without confirming their account,\n  # access will be blocked just in the third day. Default is 0.days, meaning\n  # the user cannot access the website without confirming their account.\n  config.allow_unconfirmed_access_for = 1.days\n\n  # A period that the user is allowed to confirm their account before their\n  # token becomes invalid. For example, if set to 3.days, the user can confirm\n  # their account within 3 days after the mail was sent, but on the fourth day\n  # their account can't be confirmed with the token any more.\n  # Default is nil, meaning there is no restriction on how long a user can take\n  # before confirming their account.\n  config.confirm_within = 1.days\n\n  # If true, requires any email changes to be confirmed (exactly the same way as\n  # initial account confirmation) to be applied. Requires additional unconfirmed_email\n  # db field (see migrations). Until confirmed, new email is stored in\n  # unconfirmed_email column, and copied to email column on successful confirmation.\n  config.reconfirmable = true\n\n  # Defines which key will be used when confirming an account\n  config.confirmation_keys = [ :login ]\n\n  # ==> Configuration for :rememberable\n  # The time the user will be remembered without asking for credentials again.\n  # config.remember_for = 10.minutes\n\n  # Invalidates all the remember me tokens when the user signs out.\n  config.expire_all_remember_me_on_sign_out = true\n\n  # If true, extends the user's remember period when remembered via cookie.\n  # config.extend_remember_period = false\n\n  # Options to be passed to the created cookie. For instance, you can set\n  # secure: true in order to force SSL only cookies.\n  config.rememberable_options = {secure: true}\n\n  # ==> Configuration for :validatable\n  # Range for password length.\n  config.password_length = 8..128\n\n  # Email regex used to validate email formats. It simply asserts that\n  # one (and only one) @ exists in the given string. This is mainly\n  # to give user feedback and not to assert the e-mail validity.\n  # I added the requirement that the domain contain a dot and not end with a dot\n  config.email_regexp = /\\A[^@]+@[^@]+\\z/\n\n  # ==> Configuration for :timeoutable\n  # The time you want to timeout the user session without activity. After this\n  # time the user will be asked for credentials again. Default is 30 minutes.\n  config.timeout_in = 10.minutes\n\n  # If true, expires auth token on session timeout.\n  config.expire_auth_token_on_timeout = true\n\n  # ==> Configuration for :lockable\n  # Defines which strategy will be used to lock an account.\n  # :failed_attempts = Locks an account after a number of failed attempts to sign in.\n  # :none            = No lock strategy. You should handle locking by yourself.\n  config.lock_strategy = :failed_attempts\n\n  # Defines which key will be used when locking and unlocking an account\n  config.unlock_keys = [ :email ]\n\n  # Defines which strategy will be used to unlock an account.\n  # :email = Sends an unlock link to the user email\n  # :time  = Re-enables login after a certain amount of time (see :unlock_in below)\n  # :both  = Enables both strategies\n  # :none  = No unlock strategy. You should handle unlocking by yourself.\n  config.unlock_strategy = :email\n\n  # Number of authentication tries before locking an account if lock_strategy\n  # is failed attempts.\n  config.maximum_attempts = 3\n\n  # Time interval to unlock the account if :time is enabled as unlock_strategy.\n  # config.unlock_in = 1.hour\n\n  # Warn on the last attempt before the account is locked.\n  config.last_attempt_warning = true\n\n  # ==> Configuration for :recoverable\n  #\n  # Defines which key will be used when recovering the password for an account\n  config.reset_password_keys = [ :login ]\n\n  # Time interval you can reset your password with a reset password key.\n  # Don't put a too small interval or your users won't have the time to\n  # change their passwords.\n  config.reset_password_within = 1.hours\n\n  # ==> Configuration for :encryptable\n  # Allow you to use another encryption algorithm besides bcrypt (default). You can use\n  # :sha1, :sha512 or encryptors from others authentication tools as :clearance_sha1,\n  # :authlogic_sha512 (then you should set stretches above to 20 for default behavior)\n  # and :restful_authentication_sha1 (then you should set stretches to 10, and copy\n  # REST_AUTH_SITE_KEY to pepper).\n  #\n  # Require the `devise-encryptable` gem when using anything other than bcrypt\n  # config.encryptor = :sha512\n\n  # ==> Scopes configuration\n  # Turn scoped views on. Before rendering \"sessions/new\", it will first check for\n  # \"users/sessions/new\". It's turned off by default because it's slower if you\n  # are using only default views.\n  # config.scoped_views = false\n\n  # Configure the default scope given to Warden. By default it's the first\n  # devise role declared in your routes (usually :user).\n  # config.default_scope = :user\n\n  # Set this configuration to false if you want /users/sign_out to sign out\n  # only the current scope. By default, Devise signs out all scopes.\n  # config.sign_out_all_scopes = true\n\n  # ==> Navigation configuration\n  # Lists the formats that should be treated as navigational. Formats like\n  # :html, should redirect to the sign in page when the user does not have\n  # access, but formats like :xml or :json, should return 401.\n  #\n  # If you have any extra navigational formats, like :iphone or :mobile, you\n  # should add them to the navigational formats lists.\n  #\n  # The \"*/*\" below is required to match Internet Explorer requests.\n  config.navigational_formats = ['*/*', :html]\n\n  # The default HTTP method used to sign out a resource. Default is :delete.\n  config.sign_out_via = :delete\n\n  # ==> OmniAuth\n  # Add a new OmniAuth provider. Check the wiki for more information on setting\n  # up on your models and hooks.\n  # config.omniauth :github, 'APP_ID', 'APP_SECRET', scope: 'user,public_repo'\n\n  # ==> Warden configuration\n  # If you want to use other strategies, that are not supported by Devise, or\n  # change the failure app, you can configure them inside the config.warden block.\n  #\n  # config.warden do |manager|\n  #   manager.intercept_401 = false\n  #   manager.default_strategies(scope: :user).unshift :some_external_strategy\n  # end\n\n  # ==> Mountable engine configurations\n  # When using Devise inside an engine, let's call it `MyEngine`, and this engine\n  # is mountable, there are some extra configurations to be taken into account.\n  # The following options are available, assuming the engine is mounted as:\n  #\n  #     mount MyEngine, at: '/my_engine'\n  #\n  # The router that invoked `devise_for`, in the example above, would be:\n  # config.router_name = :my_engine\n  #\n  # When using omniauth, Devise cannot automatically set Omniauth path,\n  # so you need to do it manually. For the users scope, it would be:\n  # config.omniauth_path_prefix = '/my_engine/users/auth'\nend\n","active":false,"path":"/Users/camdennarzt/Developer/Ruby/blog/config/initializers/devise.rb","scroll":null,"cursor":{"row":32,"column":39}},{"diskText":"class ApplicationController < ActionController::Base\n  # Prevent CSRF attacks by raising an exception.\n  # For APIs, you may want to use :null_session instead.\n  protect_from_forgery with: :exception\n  before_action :detect_browser_os_and_device\n  before_action :configure_permitted_parameters, if: :devise_controller?\n  before_action :authenticate_user!, only: [:ping]\n\n  rescue_from CanCan::AccessDenied do |exception|\n    render(file: File.join(Rails.root, 'public/403.html'), status: :forbidden, layout: false)\n  end\n\n  def ping\n    filtered = request.env.select do |k,v| ['HTTP_USER_AGENT','REMOTE_ADDR'].include? k end\n    render json: filtered\n  end\n\n  protected\n\n    def configure_permitted_parameters\n      devise_parameter_sanitizer.for(:sign_up) { |u| u.permit(:username, :email, :password, :password_confirmation) }\n      devise_parameter_sanitizer.for(:sign_in) { |u| u.permit(:login, :username, :email, :password) }\n      devise_parameter_sanitizer.for(:account_update) { |u| u.permit(:username, :email, :password, :password_confirmation, :current_password) }\n    end\n\n  private\n  \n    def detect_browser_os_and_device\n      case request.protocol\n      when /http/i\n        request.variant = [:http]\n      when /https/i\n        request.variant = [:https]\n      end\n\n      case request.user_agent\n      when /iPad/i\n        request.variant.push(:tablet)\n      when /iPhone/i || /Windows Phone/i\n        request.variant.push(:phone)\n      when /Android/i && /mobile/i\n        request.variant.push(:phone)\n      when /Android/i\n        request.variant.push(:tablet)\n      end\n      case request.user_agent\n      when /Android/i\n        request.variant.push(:android)\n      when /iPhone/i || /iPad/i\n        request.variant.push(:ios)\n      when /Windows/i\n        request.variant.push(:windows)\n      when /Macintosh/i || /MacOS/i || /Darwin/i\n        request.variant.push(:mac)\n      when /BSD/i\n        request.variant.push(:bsd)\n      when /Linux/i || /Ubuntu/i\n        request.variant.push(:linux)\n      when /RIM/i || /Playbook/i || /BlackBerry/i || /BB10/i\n        request.variant.push(:blackberry)\n      when /CrOS/i\n        request.variant.push(:chromeos)\n      when /Firefox/i && /Mobile/i\n        request.variant.push(:firefoxos)\n      end\n      case request.user_agent\n      when /Chrome/i || /Chromium/i || /CrMo/i || /CriOS/i\n        request.variant.push(:chrome)\n      when /Firefox/i || /Fennec/i\n        request.variant.push(:firefox)\n      when /Safari/i && /Android/i\n        request.variant.push(:androidb)\n      when /Opera/i || /OPR/i || /Presto/i\n        request.variant.push(:opera)\n      when /MSIE/i || /Trident/i || /IE/i || /IEMobile/i\n        request.variant.push(:ie)\n      when /Safari/i || /iPhone/i || /iPad/i\n        request.variant.push(:safari)\n      when /RIM/i || /Playbook/i || /BlackBerry/i || /BB10/i\n        request.variant.push(:blackberryb)\n      end\n    end\n  end\n","text":"class ApplicationController < ActionController::Base\n  # Prevent CSRF attacks by raising an exception.\n  # For APIs, you may want to use :null_session instead.\n  protect_from_forgery with: :exception\n  before_action :detect_browser_os_and_device\n  before_action :configure_permitted_parameters, if: :devise_controller?\n  before_action :authenticate_user!, only: [:ping]\n\n  rescue_from CanCan::AccessDenied do |exception|\n    render(file: File.join(Rails.root, 'public/403.html'), status: :forbidden, layout: false)\n  end\n\n  def ping\n    filtered = request.env.select do |k,v| ['HTTP_USER_AGENT','REMOTE_ADDR'].include? k end\n    render json: filtered\n  end\n\n  protected\n\n    def configure_permitted_parameters\n      devise_parameter_sanitizer.for(:sign_up) { |u| u.permit(:username, :email, :password, :password_confirmation) }\n      devise_parameter_sanitizer.for(:sign_in) { |u| u.permit(:login, :username, :email, :password) }\n      devise_parameter_sanitizer.for(:account_update) { |u| u.permit(:username, :email, :password, :password_confirmation, :current_password) }\n    end\n\n  private\n  \n    def detect_browser_os_and_device\n      case request.protocol\n      when /http/i\n        request.variant = [:http]\n      when /https/i\n        request.variant = [:https]\n      end\n\n      case request.user_agent\n      when /iPad/i\n        request.variant.push(:tablet)\n      when /iPhone/i || /Windows Phone/i\n        request.variant.push(:phone)\n      when /Android/i && /mobile/i\n        request.variant.push(:phone)\n      when /Android/i\n        request.variant.push(:tablet)\n      end\n      case request.user_agent\n      when /Android/i\n        request.variant.push(:android)\n      when /iPhone/i || /iPad/i\n        request.variant.push(:ios)\n      when /Windows/i\n        request.variant.push(:windows)\n      when /Macintosh/i || /MacOS/i || /Darwin/i\n        request.variant.push(:mac)\n      when /BSD/i\n        request.variant.push(:bsd)\n      when /Linux/i || /Ubuntu/i\n        request.variant.push(:linux)\n      when /RIM/i || /Playbook/i || /BlackBerry/i || /BB10/i\n        request.variant.push(:blackberry)\n      when /CrOS/i\n        request.variant.push(:chromeos)\n      when /Firefox/i && /Mobile/i\n        request.variant.push(:firefoxos)\n      end\n      case request.user_agent\n      when /Chrome/i || /Chromium/i || /CrMo/i || /CriOS/i\n        request.variant.push(:chrome)\n      when /Firefox/i || /Fennec/i\n        request.variant.push(:firefox)\n      when /Safari/i && /Android/i\n        request.variant.push(:androidb)\n      when /Opera/i || /OPR/i || /Presto/i\n        request.variant.push(:opera)\n      when /MSIE/i || /Trident/i || /IE/i || /IEMobile/i\n        request.variant.push(:ie)\n      when /Safari/i || /iPhone/i || /iPad/i\n        request.variant.push(:safari)\n      when /RIM/i || /Playbook/i || /BlackBerry/i || /BB10/i\n        request.variant.push(:blackberryb)\n      end\n    end\n  end\n","active":false,"path":"/Users/camdennarzt/Developer/Ruby/blog/app/controllers/application_controller.rb","scroll":null,"cursor":{"row":0,"column":0}}]