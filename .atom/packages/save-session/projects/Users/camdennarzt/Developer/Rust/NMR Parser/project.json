[{"diskText":"use std::io::File;\nuse std::io::IoResult;\nuse std::io::fs::PathExtensions;\n\nfn main() { read(\".\",Some(\"fid\"),None,None,None);}\n\nfn complexify_data(data: &Vec<u32>) -> Vec<u32>{data.clone()}//\treturn data[...,::2] + data[...,1::2]*1.j\nfn reshape(data: &Vec<u32>,shape: &String)-> IoResult<Vec<u32>>{Ok(data.clone())}//native scipy or numpy or python\nfn guess_shape(size: u64) -> (String,bool){\n    /*\n    # determine complexity of last (direct) dimension\n    try:\n    aq_mod = dic[\"acqus\"][\"AQ_mod\"]\n    except KeyError:\n    aq_mod = 0\n\n    if aq_mod == 0 or aq_mod == 2:\n    cplex = False\n    elif aq_mod == 1 or aq_mod == 3:\n    cplex = True\n    else:\n    raise ValueError(\"Unknown Aquisition Mode\")\n\n    # file size\n    try:\n    fsize = dic[\"FILE_SIZE\"]\n    except KeyError:\n    print \"Warning: cannot determine shape do to missing FILE_SIZE key\"\n    return (1,),True\n\n    # extract td0,td1,td2,td3 from dictionaries\n    try:\n    td0 = float(dic[\"acqus\"][\"TD\"])\n    except KeyError:\n    td0 = 1024   # default value\n\n    try:\n    td2 = int(dic[\"acqu2s\"][\"TD\"])\n    except KeyError:\n    td2 = 0     # default value\n\n    try:\n    td1 = float(dic[\"acqu3s\"][\"TD\"])\n    except KeyError:\n    td1 = int(td2)   # default value\n\n    try:\n    td3 = int(dic[\"acqu4s\"][\"TD\"])\n    except KeyError:\n    td3 = int(td1)     # default value\n\n    # last (direct) dimension is given by \"TD\" parameter in acqus file\n    # rounded up to nearest 256\n    # next-to-last dimension may be given by \"TD\" in acqu2s. In 3D+ data\n    # this is often the sum of the indirect dimensions\n    shape  = [0,0,td2,int(np.ceil(td0/256.)*256.)]\n\n    # additional dimension given by data size\n    if shape[2] !=0 and shape[3] != 0:\n    shape[1] = fsize/(shape[3]*shape[2]*4)\n    shape[0] = fsize/(shape[3]*shape[2]*16*4)\n\n    # if there in no pulse program parameters in dictionary return currect\n    # shape after removing zeros\n    if \"pprog\" not in dic or \"loop\" not in dic[\"pprog\"]:\n    return tuple([int(i) for i in shape if i>=1]),cplex\n\n    # if pulseprogram dictionary is missing loop or incr return current shape\n    pprog = dic[\"pprog\"]\n    if \"loop\" not in pprog or \"incr\" not in pprog:\n    return tuple([int(i) for i in shape if i>=1]),cplex\n\n    # determine indirect dimension sizes from pulseprogram parameters\n    loop = pprog[\"loop\"]\n    loopn = len(loop)       # number of loops\n    li = [len(i) for i in pprog[\"incr\"]] # length of incr lists\n\n    # replace td0,td1,td2,td3 in loop list\n    rep = {'td0':td0,'td1':td1,'td2':td2,'td3':td3}\n    for i,v in enumerate(loop):\n    if v in rep.keys():\n    loop[i] = rep[v]\n\n    # size of indirect dimensions based on number of loops in pulse program\n    # there are two kinds of loops, active and passive.\n    # active loops are from indirect dimension increments, the corresponding\n    # incr lists should have non-zero length and the size of the dimension\n    # is twice that of the active loop size.\n    # passive loops are from phase cycles and similar elements, these should\n    # have zero length incr lists and should be of length 2.\n\n    # The following checks for these and updates the indirect dimension\n    # if the above is found.\n\n    if loopn==1:    # 2D with no leading passive loops\n    if li[0]!=0:\n    shape[2] = loop[0]\n    shape = shape[-2:]\n\n    elif loopn==2:  # 2D with one leading passive loop\n    if loop[0]==2 and li[0]==0 and li[1]!=0:\n    shape[2] = 2*loop[1]\n    shape = shape[-2:]\n\n    elif loopn==3:  # 2D with two leading passive loops\n    if loop[0]==2 and loop[1]==2 and li[0]==0 and li[1]==0 and li[2]!=0:\n    shape[2] = 2*loop[2]\n    shape = shape[-2:]\n\n    elif loopn==4:  # 3D with one leading passive loop for each indirect dim\n    if loop[0]==2 and li[0]==0 and li[1]!=0:\n    shape[2] = 2*loop[1]\n    if loop[2]==2 and li[2]==0 and li[3]!=0:\n    shape[1] = 2*loop[3]\n    shape = shape[-3:]\n\n    elif loopn==5:  # 3D with two/one leading passive loops\n    if loop[1]==2 and li[0]==0 and li[1]==0 and li[2]!=0:\n    shape[2] = 2*loop[2]\n    if loop[3]==2 and li[0]==0 and li[3]==0 and li[4]!=0:\n    shape[1] = 2*loop[4]\n    shape = shape[-3:]\n\n    elif loopn==6:  # 4D with one leading passive loop for each indirect dim\n    if loop[0]==2 and li[0]==0 and li[1]!=0:\n    shape[2] = 2*loop[1]\n    if loop[2]==2 and li[2]==0 and li[3]!=0:\n    shape[1] = 2*loop[3]\n    if loop[4]==2 and li[4]==0 and li[5]!=0:\n    shape[0] = 2*loop[5]\n\n    elif loopn==7:\n    if loop[1]==2 and li[0]==0 and li[1]==0 and li[2]!=0:\n    shape[2] = 2*loop[2]\n    if loop[3]==2 and li[0]==0 and li[3]==0 and li[4]!=0:\n    shape[1] = 2*loop[4]\n    if loop[5]==2 and li[0]==0 and lo[5]==0 and li[6]!=0:\n    shape[0] = 2*loop[6]\n\n    return tuple([int(i) for i in shape if i>=2]),cplex\n     */\n    (String::new(),false) }\n\nfn get_data(f: &Path, big: bool) -> IoResult<(u64,Vec<u32>)>{\n    let mut file = File::open(f);\n    let mut v = vec![];\n    let size = match f.stat(){\n        Err(e) => fail!(format!(\"{}\",e)),\n        Ok(stat) => stat.size\n    };\n    let grab = if big {\n        || -> IoResult<u32>{ file.read_be_u32() }\n    } else {\n        || -> IoResult<u32>{ file.read_le_u32() }\n    };\n    for _ in range_step(0u64, size, 4u64){\n        v.push(match grab(){\n            Err(e)=>{println!(\"couldn't read a u32, {}, using 0\",e); 0},\n            Ok(i)=> i\n        });\n    }\n    Ok((size,v))\n}\n\nfn read_binary(path: Path, shape: String,cplex: bool,big: bool) -> (u64,Vec<u32>) {\n    match get_data(&path, big) {\n        Err(e) => fail!(format!(\"failed to read {} file.\", e)),\n        Ok((size,data)) => {\n            let udata = if cplex {\n                complexify_data(&data)\n            }else{\n                data\n            };\n            match reshape(&udata,&shape){\n                Err(e) => {\n                    println!(\"Warning: {} cannot be shaped into {}\",udata,shape);\n                    (size,udata)\n                },\n                Ok(s) => (size,s)\n            }\n        }\n    }\n}\n\nfn read(dir: &str,bin_file: Option<&str>,shape: Option<String>,cplex: Option<bool>,big: Option<bool>) -> Option<Vec<u32>> {\n    let path = Path::new(dir);\n    let mut ret_val : Vec<u32>;\n    if path.exists() && path.is_dir() {\n        ret_val = match match bin_file {\n            None => {\n                if path.join(\"fid\").exists() { Ok(\"fid\") }\n                else if path.join(\"ser\").exists() { Ok(\"ser\") }\n                else { Err(format!(\"no Bruker binary file could be found in {}\",path.display())) }\n            },\n            Some(bin_file_name) => Ok(bin_file_name)\n        } {\n            Err(e) => fail!(\"{}\",e),\n            Ok(file_name) => {\n                let full_path = path.join(file_name);\n                let (gshape,gcplex) = guess_shape(\n                    match full_path.stat() {\n                        Err(why) => fail!(\"{}\", why.desc),\n                        Ok(stat) => stat.size\n                    }\n                    );\n\n                let (size,data) = read_binary(full_path, match shape{\n                    None => {\n                        // if gcplex==true {\n                        //     let t = [gshape];\n                        //     t[-1]=t[-1]/2;\n                        //     gshape = tuple(t);\n                        // }\n                        gshape\n                    },\n                    Some(ashape) => ashape\n                }, match cplex{\n                    None => gcplex,\n                    Some(acplex) => acplex\n                }, match big{\n                    None => false,\n                    Some(b) => b\n                });\n                data\n            }\n        };\n    }else{\n        fail!(format!(\"directory {} does not exist\",path.display()));\n    }\n    Some(ret_val)\n}\n","text":"use std::io::File;\nuse std::io::IoResult;\nuse std::io::fs::PathExtensions;\n\nfn main() { read(\".\",Some(\"fid\"),None,None,None);}\n\nfn complexify_data(data: &Vec<u32>) -> Vec<u32>{data.clone()}//\treturn data[...,::2] + data[...,1::2]*1.j\nfn reshape(data: &Vec<u32>,shape: &String)-> IoResult<Vec<u32>>{Ok(data.clone())}//native scipy or numpy or python\nfn guess_shape(size: u64) -> (String,bool){\n    /*\n    # determine complexity of last (direct) dimension\n    try:\n    aq_mod = dic[\"acqus\"][\"AQ_mod\"]\n    except KeyError:\n    aq_mod = 0\n\n    if aq_mod == 0 or aq_mod == 2:\n    cplex = False\n    elif aq_mod == 1 or aq_mod == 3:\n    cplex = True\n    else:\n    raise ValueError(\"Unknown Aquisition Mode\")\n\n    # file size\n    try:\n    fsize = dic[\"FILE_SIZE\"]\n    except KeyError:\n    print \"Warning: cannot determine shape do to missing FILE_SIZE key\"\n    return (1,),True\n\n    # extract td0,td1,td2,td3 from dictionaries\n    try:\n    td0 = float(dic[\"acqus\"][\"TD\"])\n    except KeyError:\n    td0 = 1024   # default value\n\n    try:\n    td2 = int(dic[\"acqu2s\"][\"TD\"])\n    except KeyError:\n    td2 = 0     # default value\n\n    try:\n    td1 = float(dic[\"acqu3s\"][\"TD\"])\n    except KeyError:\n    td1 = int(td2)   # default value\n\n    try:\n    td3 = int(dic[\"acqu4s\"][\"TD\"])\n    except KeyError:\n    td3 = int(td1)     # default value\n\n    # last (direct) dimension is given by \"TD\" parameter in acqus file\n    # rounded up to nearest 256\n    # next-to-last dimension may be given by \"TD\" in acqu2s. In 3D+ data\n    # this is often the sum of the indirect dimensions\n    shape  = [0,0,td2,int(np.ceil(td0/256.)*256.)]\n\n    # additional dimension given by data size\n    if shape[2] !=0 and shape[3] != 0:\n    shape[1] = fsize/(shape[3]*shape[2]*4)\n    shape[0] = fsize/(shape[3]*shape[2]*16*4)\n\n    # if there in no pulse program parameters in dictionary return currect\n    # shape after removing zeros\n    if \"pprog\" not in dic or \"loop\" not in dic[\"pprog\"]:\n    return tuple([int(i) for i in shape if i>=1]),cplex\n\n    # if pulseprogram dictionary is missing loop or incr return current shape\n    pprog = dic[\"pprog\"]\n    if \"loop\" not in pprog or \"incr\" not in pprog:\n    return tuple([int(i) for i in shape if i>=1]),cplex\n\n    # determine indirect dimension sizes from pulseprogram parameters\n    loop = pprog[\"loop\"]\n    loopn = len(loop)       # number of loops\n    li = [len(i) for i in pprog[\"incr\"]] # length of incr lists\n\n    # replace td0,td1,td2,td3 in loop list\n    rep = {'td0':td0,'td1':td1,'td2':td2,'td3':td3}\n    for i,v in enumerate(loop):\n    if v in rep.keys():\n    loop[i] = rep[v]\n\n    # size of indirect dimensions based on number of loops in pulse program\n    # there are two kinds of loops, active and passive.\n    # active loops are from indirect dimension increments, the corresponding\n    # incr lists should have non-zero length and the size of the dimension\n    # is twice that of the active loop size.\n    # passive loops are from phase cycles and similar elements, these should\n    # have zero length incr lists and should be of length 2.\n\n    # The following checks for these and updates the indirect dimension\n    # if the above is found.\n\n    if loopn==1:    # 2D with no leading passive loops\n    if li[0]!=0:\n    shape[2] = loop[0]\n    shape = shape[-2:]\n\n    elif loopn==2:  # 2D with one leading passive loop\n    if loop[0]==2 and li[0]==0 and li[1]!=0:\n    shape[2] = 2*loop[1]\n    shape = shape[-2:]\n\n    elif loopn==3:  # 2D with two leading passive loops\n    if loop[0]==2 and loop[1]==2 and li[0]==0 and li[1]==0 and li[2]!=0:\n    shape[2] = 2*loop[2]\n    shape = shape[-2:]\n\n    elif loopn==4:  # 3D with one leading passive loop for each indirect dim\n    if loop[0]==2 and li[0]==0 and li[1]!=0:\n    shape[2] = 2*loop[1]\n    if loop[2]==2 and li[2]==0 and li[3]!=0:\n    shape[1] = 2*loop[3]\n    shape = shape[-3:]\n\n    elif loopn==5:  # 3D with two/one leading passive loops\n    if loop[1]==2 and li[0]==0 and li[1]==0 and li[2]!=0:\n    shape[2] = 2*loop[2]\n    if loop[3]==2 and li[0]==0 and li[3]==0 and li[4]!=0:\n    shape[1] = 2*loop[4]\n    shape = shape[-3:]\n\n    elif loopn==6:  # 4D with one leading passive loop for each indirect dim\n    if loop[0]==2 and li[0]==0 and li[1]!=0:\n    shape[2] = 2*loop[1]\n    if loop[2]==2 and li[2]==0 and li[3]!=0:\n    shape[1] = 2*loop[3]\n    if loop[4]==2 and li[4]==0 and li[5]!=0:\n    shape[0] = 2*loop[5]\n\n    elif loopn==7:\n    if loop[1]==2 and li[0]==0 and li[1]==0 and li[2]!=0:\n    shape[2] = 2*loop[2]\n    if loop[3]==2 and li[0]==0 and li[3]==0 and li[4]!=0:\n    shape[1] = 2*loop[4]\n    if loop[5]==2 and li[0]==0 and lo[5]==0 and li[6]!=0:\n    shape[0] = 2*loop[6]\n\n    return tuple([int(i) for i in shape if i>=2]),cplex\n     */\n    (String::new(),false) }\n\nfn get_data(f: &Path, big: bool) -> IoResult<(u64,Vec<u32>)>{\n    let mut file = File::open(f);\n    let mut v = vec![];\n    let size = match f.stat(){\n        Err(e) => fail!(format!(\"{}\",e)),\n        Ok(stat) => stat.size\n    };\n    let grab = if big {\n        || -> IoResult<u32>{ file.read_be_u32() }\n    } else {\n        || -> IoResult<u32>{ file.read_le_u32() }\n    };\n    for _ in range_step(0u64, size, 4u64){\n        v.push(match grab(){\n            Err(e)=>{println!(\"couldn't read a u32, {}, using 0\",e); 0},\n            Ok(i)=> i\n        });\n    }\n    Ok((size,v))\n}\n\nfn read_binary(path: Path, shape: String,cplex: bool,big: bool) -> (u64,Vec<u32>) {\n    match get_data(&path, big) {\n        Err(e) => fail!(format!(\"failed to read {} file.\", e)),\n        Ok((size,data)) => {\n            let udata = if cplex {\n                complexify_data(&data)\n            }else{\n                data\n            };\n            match reshape(&udata,&shape){\n                Err(e) => {\n                    println!(\"Warning: {} cannot be shaped into {}\",udata,shape);\n                    (size,udata)\n                },\n                Ok(s) => (size,s)\n            }\n        }\n    }\n}\n\nfn read(dir: &str,bin_file: Option<&str>,shape: Option<String>,cplex: Option<bool>,big: Option<bool>) -> Option<Vec<u32>> {\n    let path = Path::new(dir);\n    let mut ret_val : Vec<u32>;\n    if path.exists() && path.is_dir() {\n        ret_val = match match bin_file {\n            None => {\n                if path.join(\"fid\").exists() { Ok(\"fid\") }\n                else if path.join(\"ser\").exists() { Ok(\"ser\") }\n                else { Err(format!(\"no Bruker binary file could be found in {}\",path.display())) }\n            },\n            Some(bin_file_name) => Ok(bin_file_name)\n        } {\n            Err(e) => fail!(\"{}\",e),\n            Ok(file_name) => {\n                let full_path = path.join(file_name);\n                let (gshape,gcplex) = guess_shape(\n                    match full_path.stat() {\n                        Err(why) => fail!(\"{}\", why.desc),\n                        Ok(stat) => stat.size\n                    }\n                    );\n\n                let (size,data) = read_binary(full_path, match shape{\n                    None => {\n                        // if gcplex==true {\n                        //     let t = [gshape];\n                        //     t[-1]=t[-1]/2;\n                        //     gshape = tuple(t);\n                        // }\n                        gshape\n                    },\n                    Some(ashape) => ashape\n                }, match cplex{\n                    None => gcplex,\n                    Some(acplex) => acplex\n                }, match big{\n                    None => false,\n                    Some(b) => b\n                });\n                data\n            }\n        };\n    }else{\n        fail!(format!(\"directory {} does not exist\",path.display()));\n    }\n    Some(ret_val)\n}\n","active":false,"path":"/Users/camdennarzt/Developer/Rust/NMR Parser/src/test.rs","scroll":128.22222222222223,"cursor":{"row":0,"column":0}}]