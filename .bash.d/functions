#!/usr/local/bin/bash

function direct_math {
    echo "scale=4; $*" | \bc -l
}

function remac {
    sudo /System/Library/PrivateFrameworks/Apple80211.framework/Resources/airport -z
    sudo ifconfig en0 ether "$(openssl rand -hex 6 | sed 's/\(..\)/\1:/g; s/.$//')"
    sudo networksetup -detectnewhardware
    ifconfig en0 | grep ether
}

function forward {
    local local=$1
    local server
    local remote

    if [[ $2 =~ .*:[0-9]+ ]]
    then
        server=$(echo "$2" | cut -f1 -d:)
        remote=$(echo "$2" | cut -f2 -d:)
    else
        server=$2
        remote=$3
    fi
    \ssh -NL "$local:localhost:$remote" "$server"
}

function cssh {
    /usr/bin/ssh -oRemoteCommand=none "$@"
}

function csudo {
    local login

    while getopts 'Aa:BbC:c:D:Eeg:Hh::iKklnPp:r:SsT:t:U:u:Vv' opt
    do
        # shellcheck disable=SC2220,SC2213
        case $opt in
            i) login=true ;;
        esac
    done

    # shellcheck disable=SC2199
    if [[ ${login:-false} == "true" || ${@: $OPTIND:1} == su ]]; then
        read -rp "Did you want sudo bash? [Yn] " yn
        case $yn in
            [Nn]* ) \sudo "$@";;
            * ) \sudo bash;;
        esac
    elif [[ ${@: $OPTIND:1} == echo ]]; then
        echo "You probably want echo | sudo tee" >&2
        builtin echo "${@: (($OPTIND+1))}"
    else
        \sudo "$@"
    fi
}

function cscp {
    if echo "$@" | xargs getopt '346BCpqrTvc:F:i:J:l:o:P:S:' -- | { read -r c; [[ "${c}" =~ --\ .*:.*\ .*:.* ]]; }; then
        # 2 remotes, cannot use rsync, try: https://unix.stackexchange.com/questions/183504/how-to-rsync-files-between-two-remotes
        \scp -3 "$@"
    else
        # shellcheck disable=SC2034
        local RSYNC_RSH="/usr/bin/ssh -oRequestTTY=no -oRemoteCommand=none"
        until rsync -aLvz --append-verify --partial --progress --timeout=10 "$@"; do sleep 1; echo retrying; done
    fi
}

function cps {
    if [ $# == 1 ]; then
        pgrep -fil "$1"
    else
        ps "$@"
    fi
}

function cfind {
    if [ "$(uname)" = "Darwin" ]; then
        find -x "$@"
    else
        #handle multiple search locations
        PLACE="$1"
        shift 1
        find "$PLACE" -xdev "$@"
    fi
}

function cdiff {
    if hash git &>/dev/null; then
        git diff --no-index --color-words "$@"
    else
        diff "$@"
    fi
}

function ramdrive {
    # diskutil erasevolume HFS+ 'ramdisk' $(hdiutil attach -nomount ram://$(echo '4 * 1024 ^ 3 / 512' | bc)) 2>/dev/null
    diskutil partitionDisk "$(hdiutil attach -nomount "ram://$(echo '4 * 1024 ^ 3 / 512' | bc)")" 1 GPTFormat APFS 'ramdisk' '100%'
}

function clocate {
    if [ "$(uname)" = "Darwin" ]; then
        mdfind "name:$*"
    else
        cdllocate "$*"
    fi
}

function csed {
    if [ "$(uname)" = "Darwin" ]; then
        sed -E "$@"
    else
        sed -r "$*"
    fi
}

function colors {
    for i in {0..31} ; do
        for j in {0..7} ; do
            printf "[7;(38;05;%d)mColor %-3d[0m\t" $((i + j * 32)) $((i + j * 32))
        done;
        echo ''
    done;
    echo -n "[0m"
}

function loveSongsForCamden {
    options_found=0
    while getopts ':vn:N:' OPT; do
        options_found=1
        # shellcheck disable=SC2214
        case $OPT in
            v|+v)
                mdfind kind:music album:camden | sort -nt / -k+11 | while read -r line; do printf "\n %s" "$line"; afplay "$line"; done &
                ;;
            n|+n)
                mdfind kind:music album:camden | sort -nt / -k+11 | grep -E --color='never' "/$OPTARG-.*$" | while read -r line; do afplay "$line"; done &
                ;;
            N|+N)
                shift $(( OPTIND - 1 ))
                OPTIND=1
                mdfind kind:music album:camden | sort -nt / -k+11 | grep -E --color='never' -i "[^/]*$*[^/]*/[^/]*$" | while read -r line; do afplay "$line"; done &
                ;;
            *)
                echo "usage: ${0##*/} [+-vn album-number] +-N album name"
                return 2
        esac
    done
    if ((!options_found));then
        mdfind kind:music album:camden | sort -nt / -k+11 | while read -r line; do afplay "$line"; done &
    fi
}

# shellcheck disable=SC2164
function chdir {
    if [ "$_" == "neofetch" ]; then
        if [ -n "$1" ]; then
            cd "${@//~\?/$HOME/}";
        else
            cd ~
        fi
    else
        if [ -n "$1" ]; then
            pushd "${@//~\?/$HOME/}";
        else
            pushd ~
        fi
    fi
}

function ccalendar {
    echo 'Today in history:'
    if [ "$TERM" != 'dumb' ]; then
        calendar 2>/dev/null | awk '{printf "%s %s",$1,$2; $1=$2=""; print "\t[0;38;5;122m"$0"[0m"}'
    else
        calendar 2>/dev/null | awk '{printf "%s %s",$1,$2; $1=$2=""; print "\t[0;36m"$0"[0m"}'
    fi
}

function getIp {
    if [ $# -gt 0 ]; then
        if [ "$1" = "-6" ]; then
            getIpv6
        elif [ "$1" = "-4" ]; then
            getIpv4
        else
            echo "Usage: getIp [-4] [-6]"
        fi
    else
        getIpv4
    fi
}

function getIpv4 {
    getIpv 4
}

function getIpv6 {
    getIpv 6
}

function getIpv {
    # dig +short myip.opendns.com @resolver1.opendns.com
    \curl "-$1" -s http://icanhazip.com/s
}

function mailIpTo {
    getIp -4 | mail -s "$(whoami)'s IP update" -F camden.narzt@gmail.com
}

function zipup {
    zip -r "$1" "$1"
    mv "$1.zip" ../
}

function fplay {
    TYPEREGEX='.*\.(3g[2|p]|a(ac|c3|dts|if[c|f]?|mr|nd|u)|caf|m4[a|r]|mp([1-4|a]|eg[0,9]?)|sd2|wav)'
    DOAPPLESCRIPT=0
    APPLESCRIPTPART1='tell application "QuickTime Player" to delay 1'
    APPLESCRIPTPART2='tell application "QuickTime Player" to play the first document'
    MUSICROOT=~/Music/
    OUTPUT1="/dev/null"
    OUTPUT2="/dev/null"
    AUTHOR=""
    ALBUM=""
    NAME=""
    PLAY=1
    INFO=0
    options_found=0
    while getopts ":sd:hgia:A:o:v" OPTION
    do
        options_found=1
        # shellcheck disable=SC2214
        case $OPTION in
            d|+d)
                MUSICROOT="$OPTARG"
                ;;
            g|+g)
                DOAPPLESCRIPT=1
                ;;
            s|+s)
                PLAY=0
                ;;
            i|+i)
                INFO=1
                ;;
            a|+a)
                AUTHOR="AND author:$OPTARG"
                ;;
            A|+A)
                ALBUM="AND album:$OPTARG"
                ;;
            o|+o)
                OUTPUT2="$OPTARG"
                ;;
            v|+v)
                OUTPUT1="/dev/stdout"
                ;;
            h|+h)
                echo "usage: ${0##*/} [+-vshgi] [+-d music-directory] [+-a album] [+-A artist] [+-o playlist] [--] search terms..."
                return
                ;;
            *)
                echo "usage: ${0##*/} [+-vshgi] [+-d music-directory] [+-a album] [+-A artist] [+-o playlist] [--] search terms..."
                return 2
                ;;
        esac
    done
    shift $((OPTIND-1))
    OPTIND=1
    if [ "$#" -gt "0" ]; then
        NAME="AND name:$*"
    fi
    if [[ ( -n $NAME ) || ((options_found -eq 1)) ]]; then
        mdfind -onlyin "$MUSICROOT" '(kind:music OR kind:movie)' "$NAME" "$AUTHOR" "$ALBUM" |
            grep -E --color=auto "$TYPEREGEX" |
            while read -r line; do
                echo "$line" | tee -a "$OUTPUT2" > "$OUTPUT1"
                if ((INFO)); then
                    afinfo "$line"
                fi
                if ((DOAPPLESCRIPT)); then
                    open -a 'QuickTime Player' "$line"
                    if ((PLAY)); then
                        osascript -e "$APPLESCRIPTPART1"
                        osascript -e "$APPLESCRIPTPART2"
                    fi
                elif ((PLAY)); then
                    # to get fplay to print the song names neatly, have it spawn a process that uses bash "wait" to wait for everything else to finish before echoing.

                    # not sure how to avoid it waiting for it's parent.
                    afplay "$line"
                fi
            done
    fi
}

function ccal {

    cat >/tmp/FileWithDates <<EOF
EOD
10 31
4 25
2 14
2 2
EOD
EOF

    cal -y | awk -v month="$(date +%m)" -v day="$(date +%e) " '
BEGIN {
    max=0
    sub(/^0/,"",month)
    months[max] = month + 0
    days[max]   = day + 0
    max++
}

NR == FNR {
    months[max] = $1 + 0
    days[max]   = $2 + 0
    max++
    next
}

{   m = (int((FNR-3)/8) * 3) + 1
    for (i=0; i<3; i++) {
        t[i] = " " substr($0,1+i*22,20) " "
         for(j=0; j < max; j++) {
            if (m+i == months[j]) {
                sub(" "days[j]" ",":"days[j]"@",t[i])
            }
        }
        gsub(/:/," \033[0;31m",t[i])
        gsub(/@/,"\033[0m ",t[i])
    }
    print t[0],t[1],t[2]
} ' /tmp/FileWithDates -
}

function password {
    cop create item login title="$*" --generate-password
}

function unix {
    date -r "$1"
}

function get_op {
    local OP_RELEASE_NOTES_URL="https://app-updates.agilebits.com/product_history/CLI"
    local OP_PLATFORM=$(uname | tr '[:upper:]' '[:lower:]')
    local OP_ARCH="amd64"

    if op_release_notes=$(curl -sfL "${OP_RELEASE_NOTES_URL}"); then
        op_url=$(echo "${op_release_notes}" | xmllint --html --xpath "string(//article[not(@class='beta')][1]/div[@class='cli-archs']/p[@class='system ${OP_PLATFORM}']/a[text()='${OP_ARCH}']/@href)" - 2>/dev/null)
        if [ -z "${op_url}" ]; then
            # If $op_url is empty (e.g. if the page layout has changed)
            echo "1Password CLI tool release notes were not in an expected format at: ${OP_RELEASE_NOTES_URL}" >&2
            echo "Please update script at ${BASH_SOURCE[*]}" >&2
        else
            # $op_url should be the URL for the latest download
            wget "${op_url}" -P ~/Downloads/
        fi
    else
        # If the curl command failed (e.g. the page was not found)
        echo "1Password CLI tool release notes were not found at: ${OP_RELEASE_NOTES_URL}" >&2
        echo "Please update script at ${BASH_SOURCE[*]}" >&2
    fi

    until ls ~/Downloads/op_${OP_PLATFORM}_${OP_ARCH}_v*.pkg &>/dev/null; do
        echo "please download op from $OP_RELEASE_NOTES_URL first"
        open "$OP_RELEASE_NOTES_URL"
        read -rp "Press enter to continue"
    done
}

function install_op {
    local OP_PLATFORM=$(uname | tr '[:upper:]' '[:lower:]')
    local OP_ARCH="amd64"
    sudo installer -pkg ~/Downloads/op_${OP_PLATFORM}_${OP_ARCH}_v*.pkg -target /
    rm ~/Downloads/op_${OP_PLATFORM}_${OP_ARCH}_v*.pkg
}

function getoplimit {
    shopt -s nullglob;
    for file in "$TMPDIR/com.agilebits.op.$(id -u)"/.??*; do
        # SB for file created time
        stat -t '%s' -f '%Sm' "$file"
    done | while read -r date; do
        date -jf "%s" -v+30M "$date" "+%s"
    done | max 2>/dev/null
}

function getPasswordFor {
    cop get item "$1" --fields password
}

function getUsernameFor {
    cop get item "$1" --fields username
}

function cop {
    if [ ! -x /usr/local/bin/op ]; then
        get_op
        install_op
    else
        local output=$(/usr/local/bin/op update)
        if [[ "$output" =~ "is now available" ]]; then
            install_op
        fi
    fi

    if [[ "$1" == "update" || "$1" == "help" || "$1" == "--update" || "$1" == "--help" ]]; then
        /usr/local/bin/op "${@#--}"
        return;
    fi

    account=narzt
    env_var="OP_SESSION_$account"
    login_path="$(readlink ~/.op/login)"
    limit="$(getoplimit)"
    if [[ $limit -le $(date "+%s") ]]; then
        unset login_path
        unset "$env_var"
    fi

    if [ -z ${!env_var} ]; then
        if [ ! -f "$login_path" ]; then
            login_path=$(mktemp)
            /usr/local/bin/op signin $account > "$login_path"
            ln -sf "$login_path" ~/.op/login
        fi
        source ~/.op/login
    fi

    if [[ "$1" == "find" || "$1" == "search" ]]; then
        shift
        /usr/local/bin/op list items | \
            ruby -rjson -e "puts JSON.parse(STDIN.read).select{|e| e['overview']['title'].downcase.include? '$*'}.flat_map{|e| [e['overview']['title'] , ' '+e['uuid'], '']}.join(\"\n\")"
    else
        /usr/local/bin/op "$@"
    fi
}

function ctar {
    local CREATE
    local FILE

    while getopts 'aBb:C:cf:HhI:JjkLlmnOoPpqrSs:T:tUuvW:wX:xyZz' opt
    do
        # shellcheck disable=SC2220,SC2213
        case $opt in
            c) CREATE=true ;;
            f) FILE=$OPTARG ;;
        esac
    done

    if ! [[ ${CREATE:-false} == "true" ]]; then
        tar "$@"
    else
        if ! [[ "${FILE:-x}" =~ .*\.t?gz ]]; then
            set -- "${*/.tar/.tgz}"
        fi
        tar "${@: 1:$((OPTIND -1))}" --use-compress-program pigz "${@: $OPTIND}"
    fi
}

function cpbcopy {
    if [ $# -ge 1 ]; then
        pbcopy < "$*"
    else
        pbcopy
    fi
}

function checkIsDistro {
    docker pull "$1:$2" &>/dev/null
}

function checkIsUbuntu {
    checkIsDistro ubuntu "$1"
}

function checkIsDebian {
    checkIsDistro debian "$1"
}

function checkIsCentOS {
    checkIsDistro centos "$1"
}

function checkIsFedora {
    checkIsDistro fedora "$1"
}

function checkIsRHEL {
    checkIsDistro "registry.access.redhat.com/$1/${1%%[0-9]*[0-9]}" latest || checkIsDistro "registry.access.redhat.com/${1/rhel/ubi}/ubi" latest
}

function cdocker {
    local IMAGE
    local args=('-l')
    if [[ "$1" == *:* ]]; then
        IMAGE="$1"
    elif checkIsUbuntu "$1"; then
        IMAGE="ubuntu:$1"
    elif checkIsDebian "$1"; then
        IMAGE="debian:$1"
    elif checkIsCentOS "$1"; then
        IMAGE="centos:$1"
    elif checkIsCentOS "${1/el/centos}"; then
        IMAGE="centos:${1/el/centos}"
    elif checkIsFedora "$1"; then
        IMAGE="fedora:$1"
    elif checkIsRHEL "$1"; then
        local RHEL_ID=nkxqcwvnljffnae3ewas2s3afq
        # shellcheck disable=SC2155
        local RHEL_USERNAME=$(getUsernameFor $RHEL_ID)
        # shellcheck disable=SC2155
        local RHEL_PASSWORD=$(getPasswordFor $RHEL_ID)
        local version=${1##[a-z]*[a-z]}
        if [[ ${version:-8} -ge 8 ]]; then
            IMAGE="registry.access.redhat.com/ubi${version}/ubi"
        else
            IMAGE="registry.access.redhat.com/rhel${version}/rhel"
        fi
        local c1="subscription-manager register --username '$RHEL_USERNAME' --password '$RHEL_PASSWORD' --auto-attach"
        # shellcheck disable=SC2016
        local c2='yum install -y https://dl.fedoraproject.org/pub/epel/epel-release-latest-$(< /etc/redhat-release tr -dc "0-9." | cut -d \. -f1).noarch.rpm'
        local c3="yum-config-manager --enable epel"
        args=('-c' "$c1 && $c2 && $c3 && exec bash -l" )
    else
        echo "Couldn't find proper distro for $1"
        return 1
    fi

    docker run -it  --security-opt seccomp=unconfined "$IMAGE" bash "${args[*]}"
}

function editDiskAccess {
    shopt -s nocasematch
    local DB="$HOME/Library/Application Support/com.apple.TCC/TCC.db"
    mapfile -t clients < <( echo "SELECT DISTINCT client FROM access WHERE client NOT LIKE '%.apple.%' ORDER BY client;" | sqlite3 -noheader -list -batch "$DB" )

    local service_width=$(echo -n kTCCServiceSystemPolicyDownloadsFolder | wc -m)
    local client_width=$(printf '%s\n' "${clients[@]}" | awk '{print length}' | max)

    echo "Programs with access rights:"
    echo
    paste <(printf "%s)\n" "${!clients[@]}") <(printf "%s\n" "${clients[@]}")
    echo
    local choice="LONG STRING THAT WILL HOPEFULLY NEVER MATCH"
    while [[ ! "${clients[@]}" =~ "${choice:-emacs}" ]] && [[ ! " ${!clients[@]} " =~ " ${choice} " ]]; do
        read -rei emacs -p "Enter your choice: " choice
    done
    if [[ " ${!clients[@]} " =~ " ${choice} " ]]; then choice="${clients[$choice]}"; fi
    echo
    echo "Access rights for ${choice:-emacs}:"
    echo
    printf "SELECT service as '%-*s', client as '%-*s' FROM access WHERE client LIKE '%%%s%%' ORDER BY client;" ${service_width} service ${client_width} client ${choice:-emacs} | sqlite3 -column -header "$DB"
    read -rp "Remove access? [yN]: " goahead
    case "${goahead:-N}" in
        "Y" ) echo "delete from access where client LIKE '%${choice:-emacs}%';" | sqlite3 "$DB";;
        *) echo "aborting";;
    esac
}

function csoftwareupdate {
    softwareupdate -l |\
        fgrep Label |\
        awk -F': ' 'BEGIN { ORS = "\0" } ; {print $2}' |\
        xargs -0 -I {} softwareupdate -d '{}'
}
